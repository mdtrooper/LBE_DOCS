======================PARTE DE CONOCIMIENTO================================

NOTAS DE INICIALIZACIÓN DE PARÁMETROS DE ALSA
=============================================

The unit of the buffersize depends on the function. Sometimes it is given in bytes, sometimes the number of frames has to be specified. 
One frame is the sample data vector for all channels. For 16 Bit stereo data, one frame has a length of four bytes. 
O sea, a 16 bits por muestra, en stereo, tenemos que un frame son 32 bits, o sea, 4 BYES POR MUESTRA. 
En la fórmula del delay, trabajamos con el TAMAÑO DE FRAME, o sea, en BYTES POR MUESTRA.

TENEMOS QUE TENER CLARO LO SIGUIENTE: ESTA FÓRMULA SIEMPRE EN LA CABEZA AL TRABAJAR CON AUDIO.
- Cuando se vacía el buffer, se llama a la rutina que lo llena de nuevo. O sea, que cuanto más grande sea el buffer, menos hay que llamar a esta rutina y por tanto menos CPU se usa.
  Pero cuanto más tardemos de una llamada a otra (cuanto mayor sea el buffer), más delay habrá.  
- El dalay depende del buffer size, la frecuencia y los bytes por muestra. O sea, depende cuánto tardemos en consumir lo que hay en el buffer: por eso, en la fórmula el tamaño
  del buffer está multiplicando, y la cantidad de info que consumimos por segundo está dividiendo. La fórmula, por lo tanto, es tan sencilla como:

	delay = tamaño_buffer / (muestras_por_segundo * bytes_por_muestra)

Muestras por segundo son los hz, o sea, la frecuencia, cuántos samples consumimos por segundo. El resultado, logicamente, estará en segundos (normalmente mucho menos que un segundo,
y lo mediremos en milisegundos).

Ahora bien,  el tamaño de buffer depende del tamaño de periodo y del número de periodos. Se entiende que se llama período poque, como la rutina que llena el buffer se llama cada vez que
este se vacía, se tarda un periodo determinado en volver a llamarse, y por eso el tamaño del buffer depende del periodo (¿cada cuándo queremos que se llame a la rutina si medimos
el tiempo en bytes? Pues cada n bytes, que es el periodo).
SE LLAMA PERIODO PORQUE determina cuánto se tarda en llamar a la función de rellenado del buffer, pero no es un periodo de tiempo, sino un número de bytes que determina
el tamaño del buffer, que se vaciará más o menos deprisa dependiendo de la frecuencia y del tamaño de frame, como hemos visto en la fórmula anterior.
La fórmula del tamaño del buffer queda así:

tamaño_buffer = tamaño_periodo * número_de_periodos.

Vale. Lo primero es que ALSA va activar una interrupción de hardware, en busca de datos que reproducir y que tenemos que tenerle listos, cada cierto tiempo. Nosotros controlamos
cada cuánto tiempo ocurre esto del siguiente modo:
Veamos: si la frecuencia son 44100Hz (44100 samples por segundo) a 16 bits por sample, en estéreo, eso son 32 bits por frame. O sea que necesitamos darle a ALSA:
44100 (frames/segundo) * 4(bytes/frame) = 176400 bytes, que tenemos que tener listos cada segundo SI ALSA INTERRUMPE CADA SEGUNDO, COSA QUE PODEMOS VARIAR.
SUPONGAMOS ahora que planteamos que ALSA haga saltar la interrupción cada medio segundo, conservando el mismo stream de 44100 muestras/segundo a 32 bits por frame (16 bit audio stereo): 
entonces, cada medio segundo tendremos que tener listos 176400/2 =  88200.
Y ahora supongamos que queremos que ALSA haga saltar la interrupción en busca de datos que reproducir cada 256ms (un cuarto de segundo): entonces necesitaremos tener listos
44100 bytes.
Y si queremos que salte cada 100ms, tendremos que tener listos 176400 * 0.1 = 17640 bytes.  
Y así es como controlamos el periodo: cada cuántos bytes queremos que salte la interrupción de ALSA que recoge datos para reproducirlos por el sistema de audio.
ALSA recibe el periodo en FRAMES, de modo que:
-Si queremos que salte la interrupción cada segundo, el periodo será: 44100 frames.
-Si queremos que salte la interrupción cada medio segundo, el periodo será: 22050 frames.
-Si queremos que salte la interrupción cada 256ms, el periodo será: 11025 frames.
-Si queremos que salte la interrupción cada 100ms, el periodo será: 44100 * 0.1 = 4410 frames.
ALSA sin embargo recibe el TAMAÑO DE BUFFER, QUE SUELE SER 2*PERIODO.
¿POR QUÉ EL TAMAÑO DEL BUFFER ES 2*PERIODO AL MENOS? (Suele ser 2*periodo pero puede ser periodo * 1.x,o sea, con que sea mayor que el periodo, sin tener que
ser un múltiplo entero nos vale).
PUES ESTO ES ASÍ PORQUE CUANDO SALTA LA INTERRUPCIÓN HARDWARE, SACA LO QUE HAY EN LOS PRIMEROS N_PERIODO-BYTES DEL BUFFER Y LOS REPRODUCE, PERO
NOSOTROS TENEMOS QUE SEGUIR METIENDO COSAS EN EL BUFFER MIENTRAS: ASÍ QUE NOS CURAMOS EN SALUD Y HACEMOS QUE EL BUFFER TENGA EL DOBLE DE BYTES
QUE LOS QUE ABARCA UN PERIODO (o al menos más bytes que los que abarca un periodo).
Como ya sabemos,
tamaño_buffer = tamaño_periodo * número_de_periodos, siendo normalmente el número de periodos 2.

La función
int snd_pcm_set_params 	( 	snd_pcm_t *  	pcm,
		snd_pcm_format_t  	format,
		snd_pcm_access_t  	access,
		unsigned int  	channels,
		unsigned int  	rate,
		int  	soft_resample,
		unsigned int  	latency 
	) 	

...acepta una latencia en MICROSEGUNDOS (useconds: 1 segundo = 10^-6 microsegundos). Internamente lo convierte en buffersize.PERO CUIDADO: en el PC, al comprobar
qué periosize y qué buffersize configura realmente, encontré que la relación buffersize/periodsize es de 1 a 4, por lo que deduzco que usa cuatro periodos por buffer.
Eso, con snd_pcm_set_params() no lo podemos configurar nosotros.
Si queremos hacerlo manualmente, tenemos que usar la secuencia de paso de parámetros mediante las llamadas a sucesivas funciones snd_pcm_hw_params_set*
Tienes ejemplo y documentación en: http://users.suse.com/~mana/alsa090_howto.html

DOS PROBLEMAS QUE HAY QUE REPASAR, ya que al trabajar con ALSA y SDL se hacen ambas cosas dependiendo de qué funciones usemos, ya que si vamos pasando los
parámetros uno a uno usaremos el buffersize pero si usamos snd_pcm_set_params() le pasaremos el delay. 
LA FÓRMULA BÁSICA, SIN NINGÚN ERROR POSIBLE, ES: latencia = tamaño_period * num_periods / (rate * bytes_por_frame). O SEA QUE SE CALCULA LA LATENCIA SOBRE
EL BUFFERSIZE, NO SOBRE EL PERIOD SIZE.
El repaso de estos dos problemas resume la base de lo que tenemos que tener claro al trabajar con ALSA, sin entrar en sus funciones.
Se van a repasar usando la lógica, no usando reglas de tres ni ecuaciones que aunque lo harían todo inmediato y automático, no nos dejarían entender qué pasa físicamente
con los periodos, el tamaño de buffer, el tiempo...
La explicación por la que tenemos un buffersize mayor que el periodo (normalmente buffersize = period * número_de_periodos) está más arriba, pero se resume en que cuando
ALSA activa la interrupción, se saca del buffer un periodo y se pone al principio de este lo que viene después, lo que llevamos generado a mayores, que no podemos perder. 
Si el tamaño del buffer fuese sólo el periodo, cuando se llenase un periodo ya no podríamos escribir más en el buffer.

****1 ) A partir del buffersize, obtener el delay:
Nos dan un número de bytes (buffersize) y cuántos bytes consumimos por unidad de tiempo (frecuencia * bytes_por_frame), así que, si dividimos "cuántos bytes tenemos" entre
"cuántos bytes consumimos por unidad de tiempo", y nos sale el tiempo que tardamos en consumir esos bytes, por pura lógica: lo podemos ver como "tenemos un número de bytes
y tenemos cuántos bytes se consumen por unidad de tiempo, y queremos saber cuántas veces cabe en el número total de bytes el número de bytes que se consumen por unidad
de tiempo: así que dividimos e número total de bytes entre cuántos bytes se consumen por unidad de tiempo, y obtenemos el tiempo."

Recuerda: buffersize = pediod_size * num_periods = bytes a consumir.
Así que la solución es:

delay = buffersize / (frecuencia * bytes_por_frame).

Por ejemplo: Obtener el delay para un period de 512 bytes, número de periods = 2, formato de sample de 16 bits, stereo, a 44100Hz de muestreo.
SOLUCIÓN:
Recuerda, lo dijimos al principio: vamos a trabajar en frames, o sea, en bytes por muestra.
Buffersize = 512 bytes por period * 2 periods = 1024 bytes.
Tamaño de frame es 4 bytes,  ya que son 16 bits por canal y sample, y tenemos dos canales.
Delay = 1024 bytes / 44100 frames por segundo * 4 bytes por frame = 1024 bytes / 176400 bytes por segundo consumidos = tardamos  0.0058 segundos en consumirlos,
lo que equivale a 5.8 milisegundos.

Otro ejemplo: obtener el delay para un buffersize (que ya nos dan calculado) de 2048 bytes, a 44100Hz, 16 bits, stereo.
delay = 2048 bytes a consumir / 44100 frames por segundo * 4 bytes por frame = 2048 / 176400 = 0.011 segundos = 11 milisegundos.

Y ahora, al revés: 

**** 2) A partir del delay estimado, obtener el buffersize:
Nos dan un número de milisegundos o microsegundos, y tenemos que obtener el tamaño de buffer correspondiente para una frecuencia y tamaño de frame (bytes por muestra * número de canales).
Lo podemos pensar de manera lógica como "conocemos el tiempo que tarda en agotarse el buffer, y conocemos cuántos bytes por unidad de tiempo se consumen. Luego, para saber cuántos bytes
se consumen en ese tiempo, multiplicamos el tiempo que tenemos por el número de bytes por unidad de tiempo, y lógicamente obtenemos el número de bytes que se consumen en ese tiempo". Es
como conocer a qué velocidad vamos y durante cuánto tiempo: podemos multiplicar y obtenemos la distancia recorrida.

Por ejemplo: Obtener el buffersize y el period size para un delay de 52 ms, a 44100 Hz, 16 bits, stereo, número de períodos = 2.
SOLUCIÓN:
Consumimos 44100 * 4 bytes por frame = 176400 bytes por segundo. En 0.052 segundos consumiremos: 0.052 segundos * 176400 bytes por segundo =~  9173 bytes de buffersize.
El period size, si suponemos que hay dos periodos por buffersize como dice el enunciado, será 9173 /2.

EJERCICIO FINAL:

Coger la llamada a la función:

snd_pcm_set_params(pcm_handle,
                           SND_PCM_FORMAT_S16_LE,
                           SND_PCM_ACCESS_RW_INTERLEAVED,
                           2,
                           44100,
                           0,
			   delay);

e ir metiendo el delay correspondiente a un buffer de 2048 bytes, a un buffer de 1024 bytes.. etc.
A continuación, comprobar que el buffersize y el periodsize son los esperados con las siguientes llamadas:

snd_pcm_get_params (pcm_handle, &buffer_size_frames, &period_size_frames);

buffer_size_bytes = snd_pcm_frames_to_bytes(pcm_handle, buffer_size_frames);
period_size_bytes = snd_pcm_frames_to_bytes(pcm_handle, period_size_frames);

printf("ALSA: Period size: %d frames\n", (int)period_size_frames);
printf("ALSA: Buffer size: %d frames\n", (int)buffer_size_frames);
printf("ALSA: Period size: %d bytes\n", (int)period_size_bytes);
printf("ALSA: Buffer size: %d bytes\n", (int)buffer_size_bytes);

NOTA: en el PC, al comprobar qué periosize y qué buffersize configura realmente, encontré que la relación buffersize/periodsize es de 1 a 4,
por lo que deduzco que usa cuatro periodos por buffer. Eso, con snd_pcm_set_params() no lo podemos configurar nosotros.
Si queremos hacerlo manualmente, tenemos que usar la secuencia de paso de parámetros mediante las llamadas a sucesivas funciones snd_pcm_hw_params_set*
Tienes ejemplo y documentación en: http://users.suse.com/~mana/alsa090_howto.html

=============PARTE DE BÚSQUEDA DE ERRORES EN LIBRERÍAS=================


NOTAS IMPLEMETACIÓN DE DRIVER ALSA EN SDL2: BUSCANDO POR QUÉ LA RASPBERY PI NO ACEPTA samples = 256 Y EL PC SÍ
=========================================================================================================

SDL_audio.c alrededor de la 1077
las comparaciones son contra device->spec, que contendrá los valores que nos devuelve 
current_audio.impl.OpenDevice(device, handle, devname, iscapture) < 0)
que está en la 1092
Antes de eso, device->spec contiene las especificaciones que nosotros le hemos pasado (el SDL_AudioSpec desired). Justo en esa llamada de OpenDevice, es donde
adquiere los valores que el driver le dice, LOS VALORES CORREGIDOS.
Si hacemos un step into a current_audio.impl.OpenDevice(device, handle, devname, iscapture) < 0), vemos que entra en la implementación de ALSA.
Acabamos en SDL_alsa_audio.c,que está en src/audio/alsa/SDL_alsa_audio.c,  alrededor de la línea 590.  El dev se llama ahora this. Nos interesa eguir de cerca this->spec. 
EN LA 601 SE ASIGNA el valor 1024 a samples en this->spec, ya que HA FALLADO LA ANTERIOR LLAMADA A ALSA_set_period_size() y a ALSA_set_buffer_size().
La función interesante, que es la que falla y nos altera this->spec, es ALSA_set_period_size que está en SDL_alsa_audio.c:405
La asignación del campo samples forzada se hace en SDL_alsa_audio.c, línea 377:
this->spec.samples = bufsize / 2;
frames es lo mismo que samples.


