LO MÁS BÁSICO
==============

Empezamos consiguiendo los privilegios para establecer prioridad de tiempo real en nuestros procesos.
Tienes que tener en /etc/security/limits.conf:
@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20

Puedes comprobar que tienes los límites quitados haciendo:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

Para aprovechar esto, usa "chrt -r 99", que le da prioridad realtime y no suelta la CPU
porque no hay otra aplicación a la que dársela con la misma prioridad (ROUND ROBBIN de máxima prioridad). Hay FIFO de máxima prioridad también, con lo cual
no suelta la CPU jamás, por ninguna otra aplicación, tenga la prioridad que tenga, hasta que acabe. Esto se haría con "chrt -f 99". Es peor para emuladores, laserdisc, etc...

Si no te quieres meter en mucho berenjenal, no quieres recompilar el kernel y tal, simplemente añade a los parámetros del kernel:
isolcpus=1-3
Se le puede pasar un rango de CPUs separado por un guión, tal que: isolcpus=1-3 aislaría las CPUs del 1 al 3 y dejaría la 0 para housekeeping. A las 1,2 y 3, si no les pasamos nada
con taskset no se ejecuta nada en ellas.
..para que el scheduler no elija esas CPUs para cosas del kernel ni para ninguna otra tarea multithread (como compilar con -jn), excepto que yo le diga específicamente que las use
mediante taskset.

Y luego cargas el programa, por ejemplo, con taskset -c 2 <mombre_programa> para que se ejecute en la CPU 2, que está "aislada" de procesos del kernel, y listo.
O con taskset -c 2,3, si quieres elegir varias (si el proceso es multithread) y ya.
NOTA: PARA QUE EL PROGRAMA REALMENTE USE LAS CPUs DE LA LISTA QUE LE PASAS A TASKSEL, TIENES QUE CAMBIAR LA POLÍTICA DE SCHEDULING DEL PROCESO, O SI NO
SÓLO ELEGIRÁ LA PRIMERA DE LA LISTA (esto es porque la política de scheduling por defecto, SCHED_OTHER, sólo elige la primera CPU, así que usamos SCHED_RR) . Así que haríamos:
chrt -r 99 taskset -c 1-3 <programa>

Por ejemplo: pogamos que tenemos aisladas las CPUs 1,2 y 3, y queremos compilar un programa usando esas tres CPUs: pues haríamos
chrt -r 99 tasksel -c 1,2,3 make -j4
(o bien chrt -r 99 tasksel -c 1-3 make -j4, que es lo mismo sólo que pasando la lista de CPUs separaga por un guión)

Los emuladores, como no suelen usar varios threads, con mandarlos a una CPU aislada basta, en plan:
taskset -c 3 <emulador>

Para ver mejor estas cosas en TOP, a parte de activar que se vea la CPU (F y luego darle a D sobre la opción), puedes poner un periodo más pequeño pusaldo D directamente y
metiendo algo como 0.1.

EL RESÚMEN QUE SIGUE ES TODO LO QUE TIENES QUE SABER:
EN RESÚMEN: HABIENDO AISLADO LAS CPUs DEL 1 al 3 CON "isolcpus=1-3" EN CMDLINE.TXT: 
-Para lanzar algo como un emulador que no son multithread:
taskset -c 3 ./retroarch
-Para lanzar algo MUY multithread (y que por tanto puede aprovechar varios cores) como el GZDOOM:
chrt -r 99 taskset -c 1-3 ./gzdoom
CUIDADO con el -r 99: si se te cuelgan cosas bájalo a 80.

Luego hay cosillas para disminuir el jittering sin recompilar el kernel. Las pistas las he sacado de aquí:
http://highscalability.com/blog/2015/4/8/the-black-magic-of-systematically-reducing-linux-os-jitter.html
Un resúmen con instrucciones específicas:
-De las Transparent Huge Pages me olvido, porque al hacer "sudo sysctl -a | grep hugepage" veo que no hay de eso en mi sistema. En caso de haberlas, mira esto:
 https://unix.stackexchange.com/questions/99154/disable-transparent-hugepages
-Desactivamos el swappiness poniendo en el /etc/rc.local:
echo 0 > /proc/sys/vm/swappiness

PREFACIO
=========

https://www.kernel.org/doc/Documentation/kernel-per-CPU-kthreads.txt
https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt
https://access.redhat.com/sites/default/files/attachments/201501-perf-brief-low-latency-tuning-rhel7-v1.1.pdf

Se trata de dejar todos los threads del kernel que podamos en UNA sola CPU, que llamaremos "housekeeping CPU", y el resto de CPUs quedarán libres de jittering ya que estos hilos
no corren en ellas.

Los kthreads de RCU podrian no existir si compilamos con CONFIG_PREEMPT=n, pero claro, eso NO interesa para tiempo real, lo dice uno de los docs.

PARTE 1: Los TICKS de sistema
==========================

Esto es para que no se le manden a todos los cores ticks de manera contínua. Esto es bueno para tener cores donde sólo se ejecuta UN y sólo UN programa, y un core de housekeeping
donde mandamos todos los theads del kernel. 

En GENERAL SETUP->TIMERS SUBSYSTEM, elegimos
Full dynticks system (tickless)
y también 
Full dynticks system on all CPUs by default (except CPU 0)

Eso ya nos condiciona a que la única CPU que va a tener TICKS periódicos (que son para proporcionar hora del sistema y cosas así) es sólo la 0.
Las demás serán con ticks dinámicos o DYNTICS, que es mejor para realtime.

(sacado de https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt)
"The CONFIG_NO_HZ_FULL=y Kconfig option causes the kernel to avoid
sending scheduling-clock interrupts to CPUs with a single runnable task,
and such CPUs are said to be "adaptive-ticks CPUs".  This is important
for applications with aggressive real-time response constraints because
it allows them to improve their worst-case response times by the maximum
duration of a scheduling-clock interrupt."

PARTE 2: Los RCU
===============

En GENERAL SETUP->RCU SUBSYSTEM, elegimos
Offload RCU callback processing from boot-selected CPUs,
de manera que el procesado de callbacks del kernel se mande a hilos tipo rcu* que podemos mover a la CPU de housekeeping.

No build_forced no-CBs CPUs, 
de  manera que no haya una CPU libre de threads rcu* sino que luego movamos nosotros esos hilos a la CPU de housekeeping.

Pulsa "?" sobre "Offload RCU callback processing from boot-selected CPUs" y lee sobre los nombres de los threads de control que se van a crear
a partir de ahora, y que puedes mover a la CPU que quieras.
Se puede usar el parámetro del kernel rcu_nocbs=... para especificar qué CPUs descargar de callbacks en tiempo de arranque, por ejemplo con rcu_nocbs=1,2,3
se dejan las CPUs 1, 2 y 3 sin RCU callbacks y todas irán en la 1. 
También se pueden mover los threads RCU después de arrancar a una CPU concreta, como vamos a ver a continuación, en este caso la 0, con:

for i in `pgrep rcuo` ; do taskset -pc 0 $i ; done

Si lo has hecho bien (con que le pases rcu_nocbs=1,2,3 vale, si tienes las opciones correctas en el kernel), en TOP tienes que ver que, por ejemplo, los threads
rcuop/2
rcuob/2
rcuos/2
rcuop/3
rcuob/3
rcuos/3
...tienen que estar en la CPU 0, a pesar de que son de la 2 y la 3 (para mirarlo, ahí abajo tienes apuntes de TOP de cómo se mira en qué CPU corrió el thread por última vez).

PARTE 3: ISOLCPUS
================

Vamos a decirle al scheduler que no elija ciertos cores para ejecutar cosas. Le pasamos al kernel el parámetro:
isolcpus=1,2,3
para que sólo elija el core 0 a la hora de pasarle "trabajo".

Además, en combinacion, cogemos y lanzamos nuestro programa "delicado" pegado a una CPU concreta, de las que tenemos aisladas, así:
taskset -c 3 <nombre_programa>

Puede ser una lista de cpus:
taskset -c 1,2,3 <nombre_programa>

OTRAS COSAS
============

En GENERAL SETUP, deshabilitamos el PROFILING SUPPORT (lo que se lleva por delante el oprofile).
Quedaría mirar lo de compilar sin governor, en CPU POWER MANAGEMENT -> CPU FREQUENCY SCALING, y luego poner la velocidad de la CPU a mano.
Mírate "man 2 sched_setaffinity" si quieres controlar que un thread determinado tenga afinidad a una CPU.

CÓMO COMPROBAR EN QUÉ CPU CORRE CADA PROCESO
==================================================

En TOP, pulsamos F mientras estamos ejecutándolo. En el menú que nos sale, podemos pulsar D sobre lo que queramos que se vea / que no se vea, elegimos que se vea
el campo "P       = Last Used Cpu (SMP)", y le damos a ESCAPE, de manera que podemos ver en qué CPU corre cada cosa.
